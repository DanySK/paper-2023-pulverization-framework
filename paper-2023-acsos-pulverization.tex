\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{listing-style}

\usepackage{cleveref}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
    
\newcommand{\meta}[1]{{\color{blue}#1}}    
    
\begin{document}

\title{Declarative runtime reconfiguration of pulverised distributed systems
\thanks{Identify applicable funding agency here. If none, delete this.}
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Danilo Pianini}
\IEEEauthorblockA{\textit{Department of Computer Science and Engineering} \\
\textit{Alma Mater Studiorum---Università di Bologna}\\
Cesena, Italy \\
danilo.pianini@unibo.it}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Roberto Casadei}
\IEEEauthorblockA{\textit{Department of Computer Science and Engineering} \\
\textit{Alma Mater Studiorum---Università di Bologna}\\
Cesena, Italy \\
roby.casadei@unibo.it}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Nicolas Farabegoli}
\IEEEauthorblockA{\textit{Department of Computer Science and Engineering} \\
\textit{Alma Mater Studiorum---Università di Bologna}\\
Cesena, Italy \\
nicolas.farabegoli@unibo.it}
\and
\IEEEauthorblockN{4\textsuperscript{th} Mirko Viroli}
\IEEEauthorblockA{\textit{Department of Computer Science and Engineering} \\
\textit{Alma Mater Studiorum---Università di Bologna}\\
Cesena, Italy \\
email address or ORCID}
}

\maketitle

\begin{abstract}
In recent years, we witnessed a radical change in the deployed form of distributed systems.
%
Modern applications are designed to be executed on very diverse devices
and to be deployed on heterogeneous infrastructures,
ranging from cloud servers to mobile and IoT devices.
%
De facto, complex distributed computation is happening across a cloud-edge continuum composed of heterogeneous devices and infrastructures.
%
The availablity of such an infrastructure opens to new possibilities in terms of better resource utilisation and performance,
but also poses new challenges to the application designer,
as the application must be conceived to be able to adapt its deployment to changing conditions.
%
In this paper we present a framework for the development of distributed systems
based on the concept of \emph{pulverisation},
which is meant to neatly separate business logic and deployment concerns,
allowing applications to be defined independent of the infrastructure they will execute upon.
%
The framework is based on a domain-specific language capturing,
in a declarative fashion,
the concepts composing a pulverised application and any potential target network,
also allowing for the specification of reconfiguration policies.
%
The framework, implemented in Kotlin multiplatform and available as open source,
is then evaluated in a small-scale real-world demo and in a city-scale simulated scenario.
\end{abstract}

\begin{IEEEkeywords}
runtime reconfiguration, distributed systems, self-adaptation, self-organisation, pulverisation
\end{IEEEkeywords}

\newcommand{\ourframework}{Porbione}

\section{Introduction}\label{sec:introduction}

Recent research trends in topics related to the Internet of Things promote the idea of a cloud-edge continuum~\cite{DBLP:journals/iot/BittencourtISFM18},
an infrastructure composed of heterogeneous devices ranging from large and powerful cloud servers to small connected things
on which software computes in a distributed fashion,
optimising for performance and resource utilisation.
%
Exploiting this intriguing infrastructure, however, poses new challenges to the application designer.
%
Commonly, in fact, applications are designed with a specific infrastructure in mind,
whose assumptions leak into the application logic.

Previous work suggests a technique for decoupling business logic and deployment concerns
called \emph{pulverization}~\cite{FI2020-pulverization}.
%
In short, the core idea is to consider devices as \emph{logical} entities,
whose software can be designed as (or broken down to, if already existing) an ensemble of five micro-components
(behaviour, state, communication, sensors, and actuators)
whose actual host can be decided at deployment time.
%
This way, the designer can focus on the business logic at hand,
delaying an optimised deployment to later stages of the sofware design,
thus gaining resilience to changing infrastructures or non-functional requirements.
%
One limitation of the current pulverisation approach regards dynamicity:
although the application can be deployed on arbitrary systems,
there is no support for the reconfiguration of components in face of changing conditions or requirements.

In this work,
we continue the research on pulverised systems by providing two key contributions:
first, we extend the theoretical framework of pulverisation by adding support for
\emph{runtime configuration rules}, allowing pulverised components to move at runtime across different hosts;
the providing a practical implementation called \ourframework{} which,
to the best of our knowledge,
is the first \emph{practical framework supporting pulverisation} for a general-purpose language.
%
We exercise \ourframework{} with two case studies:
a small-scale real-wold demonstration, and a city-scale simulated scenario.

\begin{itemize}
    \item need for deployment-independent specs
    \item need for runtime reconfiguration (achieve QoS in face of changing conditions --- green computing?)
    \item declarativity over imperative approaches (note: can be compared with the trend in general softeng/build systems)
\end{itemize}

+ related work

\section{A framework for declarative runtime reconfiguration}\label{sec:contribution}

\subsection{Domain model}

\subsection{Domain-specific language}

The framework allows the system configuration via two distinct DSLs, one for defining the system's devices and their components,
and one for defining the runtime configuration of the system.

The first domain-specific language allows to define the system in terms of
\emph{devices}, \emph{components} and which \emph{capabilities} requires to be executed.
%
In this way, infrastructural and deployment aspects are abstracted, allowing the focus to be on functional aspects of the system.
%
The DSL enables the definition of the type of devices that took part in the system,
and for each device can be specified which components constitute it and where those component must run on (e.g. which host must execute the component).
%
The execution of a component is constrained to hosts with predetermined characteristics:
the framework models the constraint with the \texttt{Capability} concept,
namely the property that a host must to ``implement'' to run the component.
%
Different capabilities can be specified for each component to provide a more flexible and scalable deployment of the system.

The~\Cref{lst:system-configuration} provides an example of the usage of the domain-specific language where is defined a system composed of two kind of devices.
%
The DSL returns the system's configuration that will be used by the runtime.

One key-point of the domain-specific language can be observed in the definition of the \texttt{device-2} device:
the \emph{Behaviour} component can be deployed on hosts that implement the \texttt{HighCPU} and \texttt{EmbeddedDevice} capabilities,
in this way the behaviour can be moved (at runtime) from a host to another one that implements the same capabilities.
%
The association between a component and a single capability do not necessarily imply that the component can be executed only on a single host,
but it is the way to specify the minimum requirements for the host that will execute the component.

\lstinputlisting[
    float=ht,
    language=Kotlin,
    caption={
        Example of the usage of the domain-specific language for the system configuration.
        The example configures two types of devices, and for each device defines the components that compose it and which capabilities requires for the execution.
    },
    label=lst:system-configuration,
]{listings/SystemConfig.kt}

The second domain-specific language allows to define the concrete implementation of each component associating it to a specific start host;
moreover, it allows to define the creteria on which the system should be reconfigured by specifying which events should trigger a reconfiguration.
%
This DSL binds the more abstrac definition specified in the previous DSL to the topology of the available infrastracture,
defining the actual deployment of the system, and the reconfiguration policies.
%
The~\Cref{lst:runtime-configuration} provides an example of the usage of the domain-specific language where is defined the runtime configuration of the system.
%
The framework define the concept of \texttt{Host} that is the representation of an available physical host where the components can be deployed;
for each host is possible to specify the capabilities that it implements.
%
In this way, the framework can check if a host can execute a component by verifying if the host implements the required capabilities.
%
The runtime is configured be specifying for each implementation of a \emph{component},
its associated startup host enabling the definition of the initial deployment of the system.
%
The most relevant part of the domain-specific language, is the definition of the reconfiguration rules:
the framework models the concept of \texttt{ReconfigurationEvent}
that is the event that triggers the reconfiguration of the system.
%
The DSL allows the association of a \texttt{ReconfigurationEvent}
to a new deployment of the system which is defined as the new association between component and host.

\lstinputlisting[
    float=ht,
    language=Kotlin,
    caption={
        Example of the usage of the domain-specific language for the runtime configuration.
        The example defines the runtime configuration of the system, specifying the initial deployment and the reconfiguration rules.
    },
    label=lst:runtime-configuration,
]{listings/RuntimeConfig.kt}

A \texttt{ReconfigurationEvent} is characterized by the \emph{events}
that it produces and the \emph{condition} that must be satisfied to trigger the reconfiguration.
%
The \emph{events} are represented as an asyncronous stream of valued produced by the device and the
\emph{condition} is a predicate that is evaluated on the stream of events.
%
At the first match of the condition, the reconfiguration is triggered and the system is reconfigured with the new deployment.
%
The~\Cref{lst:reconfiguration-events} shows an example of the definition of a reconfiguration event.

\lstinputlisting[
    float=ht,
    language=Kotlin,
    caption={Example of the definition of a reconfiguration event.},
    label=lst:reconfiguration-events,
]{listings/ReconfigurationEvents.kt}

\subsection{Implementation details}

Also mention that is multiplatform

\section{Evaluation}\label{sec:evaluation}

The pulverization approach tries to solve the problem of the deployment independence of the system, in heterogeneous infrastructures.
%
The dynamic reconfiguration of the system is a key point to achieve flexibility and adaptability of the system on the requirements changing.
%
In this section are presented two case studies that show the effectiveness of the approach:
the first case study shows the operation of the framework in a small-scale scenario, while the second case study simulate a large-scale scenario
using the framework in a simulated environment showing the effectiveness of the approach in many different conditions.

\subsection{Metrics}
\meta{descrizione}

As follow are reported the free variables used in the evaluation:
\begin{itemize}
    \item let $n$ be the number of devices;
    \item let $t_d$ be the discharge time of the battery of the devices;
    \item let $B_l$ be the low battery threshold;
    \item let $B_h$ be the high battery threshold;
    \item let $EPI_{cloud}$ be the energy per instruction of the cloud;
    \item let $EPI_{ratio}$ be the ratio of the consumption of the cloud and the device;
\end{itemize}

From the variables above are derived the following metrics:

\begin{itemize}
    \item let $\beta_{device}$ be the number of \emph{behaviour} executed in the device;
    \item let $\beta_{cloud}$ be the number of \emph{behaviour} executed in the cloud;
    \item let $C_{\%}$ be the average battery percentage of the devices;
    \item let $P_{devices}$ be the consumed power of the devices;
    \item let $P_{cloud}$ be the consumed power of the cloud;
    \item let $P_{total}$ be the total consumed power of the system;
    \item let $I_{cloud}$ be the number of server instances of the cloud;
    \item let $\$_{cloud}$ be the cost of the cloud; 
\end{itemize}


\subsection{Small scale: crowd alert}

\subsection{Large scale: smart city application}
\cite{PianiniJOS2013}


\section{Related Work}

A recent survey on 
 formal techniques for verifying the correctness of reconfigurations
 in component-based distributed software systems is provided in~\cite{coullon2023swreconfig}.

\meta{
%
%\subsection{Approaches to Deployment Independence}
%\label{s:rw:deployment-independence}
%
%\meta{TODO: add works on deployment independence, e.g., osmotic~\citep{DBLP:journals/computer/VillariFDRJR19}, BIP~\citep{lekidis2015bip-wsn,bastarrica2001optimization-techniques-deployment-components-bip}}
%
We highlight a number of representatieve research efforts on deployment and automatic reconfiguration of systems.
%
%For instance, 
\emph{Osmotic computing}~\cite{DBLP:journals/computer/VillariFDRJR19} is an approach to opportunistic deployment of microservices on the edge-fog-cloud platform.
An osmotic platform aims to reach and maintain an ``osmotic equilibrium'' 
between infrastructural and application requirements
by automatically migrating microservices to deployment locations.
%
However, the approach mainly targets centrally orchestrated systems.
%
Other approaches leverage component-based, architectural descriptions to decouple application logic and deployment.
%
For instance, \emph{DR-BIP (Dynamically Reconfigurable - Behaviour Interaction Priority model)}~\cite{,Ballouli18dr-bip}
and \emph{DReAM (Dynamically Reconfigurable Architectural Modelling)}~\cite{denicola2020dream-dynamic-reconfig-arch-modelling}
use \emph{components} (capturing behaviour), \emph{connectors} (capturing interaction between components' \emph{ports}), 
\emph{maps} (logical topologies),
and \emph{deployments} (associating components to map locations),
overall organised in \emph{motifs} (dynamic architectural configurations),
to model and analyse dynamic architectures.
%

These approaches have some similarity with the approach presented in this paper, but they are arguably more complex and our  
%than the one introduced in this paper,
 %, though also fostering an exogenous, declarative (logics-based) modelling approach.
approach explicitly addresses self-organising CPS.
%
%
%By constrast, our approach explicitly addresses self-organising CPS.
%
%A more in-depth, formal comparison is left as future work.
}

\section{Conclusion and future work}\label{sec:conclusion}

global policies

\bibliographystyle{IEEEtran}
\bibliography{bibliography}

%\vspace{12pt}
%\color{red}
%IEEE conference templates contain guidance text for composing and formatting conference papers. Please ensure that all template text is removed from your conference paper prior to submission to the conference. Failure to remove the template text from your paper may result in your paper not being published.

\end{document}
