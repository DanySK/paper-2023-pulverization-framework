\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{acronym}
\usepackage{listing-style}
\usepackage[hidelinks]{hyperref}
\usepackage[inline]{enumitem}

\acrodef{dsl}[DSL]{domain-specific language}
\acrodef{iot}[IoT]{Internet of Things}
\acrodef{cas}[CAS]{collective adaptive system}
\acrodef{qos}[QoS]{quality of service}

\usepackage{cleveref}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
    
\newcommand{\meta}[1]{{\color{blue}#1}}    

\makeatletter
\newcommand{\linebreakand}{%
  \end{@IEEEauthorhalign}
  \hfill\mbox{}\par
  \mbox{}\hfill\begin{@IEEEauthorhalign}
}
\makeatother

    
\begin{document}

\title{Declarative Deployment Reconfiguration of Pulverised Collective Adaptive Systems at Runtime
\thanks{Identify applicable funding agency here. If none, delete this.}
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Danilo Pianini}
\IEEEauthorblockA{\textit{Department of Computer Science and Engineering} \\
\textit{Alma Mater Studiorum---Università di Bologna}\\
Cesena, Italy \\
danilo.pianini@unibo.it}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Roberto Casadei}
\IEEEauthorblockA{\textit{Department of Computer Science and Engineering} \\
\textit{Alma Mater Studiorum---Università di Bologna}\\
Cesena, Italy \\
roby.casadei@unibo.it}
\linebreakand
\IEEEauthorblockN{3\textsuperscript{rd} Nicolas Farabegoli}
\IEEEauthorblockA{\textit{Department of Computer Science and Engineering} \\
\textit{Alma Mater Studiorum---Università di Bologna}\\
Cesena, Italy \\
nicolas.farabegoli@unibo.it}
\and
\IEEEauthorblockN{4\textsuperscript{th} Mirko Viroli}
\IEEEauthorblockA{\textit{Department of Computer Science and Engineering} \\
\textit{Alma Mater Studiorum---Università di Bologna}\\
Cesena, Italy \\
mirko.viroli@unibo.it}
}

\maketitle

\begin{abstract}
In recent years,
the infrastructure supporting the execution of situated distributed computations
evolved with a fast pace.
%
Modern collective adaptive applications -- as found in the Internet of Things, swarm robotics, and social computing -- are designed to be executed on very diverse devices
and to be deployed on infrastructures composed of devices ranging from cloud servers to wearable devices,
constituting together a cloud-edge continuum.
%
The availability of such an infrastructure opens to better resource utilisation and performance,
but, contextually, introduces new challenges to software designers,
as applications must be conceived to be able to adapt their deployment to changing deployment domains and conditions.
%
In this paper,
we introduce a practical framework for the development of collective adaptive systems
based on the concept of \emph{pulverisation},
meant to neatly separate business logic and deployment concerns,
allowing applications to be defined independent of the infrastructure they will execute upon.
%
The framework is based on a domain-specific language capturing,
in a declarative fashion,
pulverised application components, device capabilities, resource allocation, and (runtime re-) configuration policies.
%
The framework, implemented in Kotlin multiplatform and available as open source,
is then evaluated in a small-scale real-world demo and in a city-scale simulated scenario,
 \meta{showing that ???}.
\end{abstract}

\begin{IEEEkeywords}
runtime reconfiguration, distributed systems, self-adaptation, self-organisation, pulverisation, deployment.
\end{IEEEkeywords}

\newcommand{\ourframework}{\textsc{pulse-refrakt}}

%\meta{LIMIT 10 pages incl. refs; DEADLINE 19 may}

\section{Introduction}\label{sec:introduction}

Recent technological and scientific advances
 are extending 
 both the \emph{kinds of applications and systems} that are being addressed  
 as well as their \emph{supporting infrastructure}.
%
Emerging applications
 are, for instance, those based on \emph{\acp{cas}}~\cite{DBLP:journals/sttt/NicolaJW20},
 namely collections of devices and agents
 that interact to solve problems or provide services while adapting as a whole to dynamic environments.
%
Examples include 
  large-scale sensor-actuator networks, 
  swarms of robots,
  social computing systems,
  crowds of wearable-augmented people, etc.
  supporting activities like monitoring,
  transportation, coordination, and collective intelligence.
%
Regarding infrastructure,
 it is mounting the idea of the \emph{cloud-edge continuum}~\cite{DBLP:journals/iot/BittencourtISFM18}: 
a multi-layer heterogeneous network of devices (ranging from large and powerful cloud servers to small connected \emph{things})
on which software can compute, store, and exchange data in a distributed fashion, while 
optimising for performance and resource utilisation.
%

This kind of infrastructure is also valuable for  \acp{cas}~\cite{DBLP:journals/tpds/HongCHGZ19,DBLP:journals/comsur/WangZZMLW20,DBLP:journals/comsur/AfrinJRRWH21,IEEE-IoTJ-pulverization-simulation},
which generally feature components that,
depending on the conditions at hand,
could benefit from being deployed on different devices or from \emph{offloading} some of their  tasks.
%
However, exploiting this infrastructure,
 poses new challenges to \ac{cas} application designers.
%
Commonly, in fact, applications are designed with a specific infrastructure in mind,
whose assumptions unavoidably leak into the application logic~\cite{Spolsky2004},
unless captured and encapsulated away from it:
the higher the coupling between the application and the infrastructure,
the harder it is for the former to exploit the latter's full potential and adapt to changes.

The general solution is to devise 
 a reasonable partitioning of the software system
 and a corresponding (dynamic) deployment plan 
 defining the mapping between the software components and the target deployment domain~\cite{DBLP:journals/jss/ArcangeliBL15}.
%
In the context of \acp{cas},
 previous work proposes an application partitioning schema,
 called \emph{pulverisation}~\cite{FI2020-pulverization},
 the fosters the decoupling of business logic and deployment concerns.
%
In short, the core idea is to consider devices as \emph{logical} entities,
whose software can be designed as (or broken down to, if already existing) an ensemble of \emph{five components
(behaviour, state, communication, sensors, and actuators)}
 that can be deployed with flexibility on available infrastructure without (ideally) affecting application functionality. %whose actual host can be decided at deployment time.
%
This way, the designer can focus on the business logic at hand,
delaying an optimised deployment to later stages of the sofware design,
thus gaining resilience to changes in the infrastructure or in non-functional requirements.
%
One limitation of the current pulverisation approach regards dynamicity:
although the application can be deployed on arbitrary systems,
there is no support for the reconfiguration of components at runtime, as a reaction to changing conditions or requirements.

In this work,
we continue the research on pulverised systems by providing two key contributions:
\textbf{first}, we extend the theoretical framework of pulverisation by adding support for
\emph{runtime configuration rules}, allowing pulverised components to move at runtime across different hosts;
\textbf{second}, we provide a practical implementation in Kotlin called \ourframework{} which,
to the best of our knowledge,
is the first \emph{practical framework supporting pulverisation}. % for a general-purpose language.
%
To evaluate \ourframework{}, we exercise it through two case studies:
a small-scale real-wold demonstration, and a city-scale simulated scenario.

\meta{
\begin{itemize}
    \item need for deployment-independent specs
    \item need for runtime reconfiguration (achieve \ac{qos} in face of changing conditions --- green computing?)
    \item declarativity over imperative approaches (note: can be compared with the trend in general softeng/build systems)
\end{itemize}
}

The manuscript is organised as follows.
%
\Cref{sec:background} provides background on \meta{deployment and} pulverisation.
%
\Cref{sec:contribution} describes the proposed \ac{dsl} and platform.
%
\Cref{sec:evaluation} provides an evaluation of the approach.
%
\Cref{sec:rw} covers related work.
%
Finally, \Cref{sec:conclusion} concludes the paper and highlights directions for future work.

\section{Background}\label{sec:background}

\subsection{Deployment and Reconfiguration: Basic Concepts}

The \emph{deployment view} is a well-known architectural viewpoint for software systems,
concerned with the mapping of \emph{software components} to \emph{physical machines}~\cite{DBLP:journals/software/Kruchten95}
 and supported by modelling notations like \emph{UML Deployment diagrams}.
%
Here, we provide a brief introduction to deployment and reconfiguration, based on the conceptual characterisation of~\cite{DBLP:journals/jss/ArcangeliBL15,carzaniga1998characterization}.
%
A \emph{site} is a set of computers (\emph{hosts}) that may host a \emph{software system}, i.e., a coherent collection of artifacts.
%
\emph{(Software) Deployment} is the process of moving and making a software product available and operational from one or more \emph{producer sites} to a target \emph{deployment domain} (i.e., a set of \emph{consumer sites}).
%
The \emph{deployment plan} defines 
 the mapping between the software system
 and the deployment domain,
 augmented with further information (e.g., metadata).
%
Deployment-related activities 
 include: (i) \emph{release/update} of the software system at the producer site;
 (ii) \emph{installation/deinstallation} at/from the consumer sites;
 (iii) \emph{activation/deactivation}, for starting/stopping the components;
 (iv) \emph{reorganisation} of the software system;
 and (v) \emph{redistribution}, i.e., changing the deployment plan.
 



\subsection{Pulverisation}

The goal of pulverisation~\cite{FI2020-pulverization}
is to provide application designers a way to specify the functional semantics of their software in a deployment-independent way.
%
To do so,
the application logic should be designed considering a \emph{logical system},
namely, a network of \emph{logical} devices forming a network with \emph{arbitrary} topology.
%
For a pulverisation system to work,
the application of every single logical device must be decomposable into an ensemble of \emph{pulverised components}
representing, respectively:
\begin{itemize}
    \item a set $\sigma$ of logical sensors;
    \item a set $\alpha$ of logical actuators;
    \item a state $\kappa$, representing the logical device's knowledge;
    \item a communication component $\chi$,
    handling interaction with reachable devices in the logical system, and
    \item a computation component $\beta$, modelling the behaviour of the logic device.
\end{itemize}
%
Decomposition of an application into pulverised components can be achieved in two ways:
either the application is designed with pulverisation in mind,
or the application is developed using a framework supporting automatic decomposition
(one notable example are aggregate computing frameworks~\cite{BealIEEEComputer2015}).
%
Once the application has been pulverised,
a mapping must be provided between the pulverised logical system and the hosts that will execute the pulverised components.
%
In this process,
a single logical component could be (and usually does) end up being executed on multiple hosts.

For instance, let us assume a minimal logical system counting two devices:
two rain gauges logging the water level for future reference
and opening a valve when the water level crosses a threshold in both devices.
%
Once pulverised, the logical system would be split in ten deployable pulverised components
(that we indicate with their component symbol and an index, e.g., $\sigma_1$ is the logical sensor of the first device).
%
These pulverised components can be deployed in arbitrary hosts,
as far as they have the \emph{capabilities} required to host them
(for instance, the component hosting a rain gauge logical sensor must have an actual sensor,
while the component hosting the behaviour must be sufficiently powerful to execute the logic).
%
Thus, with \emph{no change to the application logic},
the system could be deployed on very different systems:
let us assume, for instance,
that our actual target infrastructure is not composed of two connected devices,
but it is an existing \ac{iot} system
where the rain gauges are connected to two LoRaWAN motes
(which are too weak and energy-critical to execute the logic),
the valves are controlled by a dedicated device,
the levels must be logged on a database hosted on a cloud server reachable via HTTPS,
and we have an internal edge server that we can use as we please.
%
In this case, we would deploy $\sigma_1$ and $\sigma_2$ on the motes,
$\alpha_1$ and $\alpha_2$ on the valve controller,
$\kappa_1$ and $\kappa_2$ on the cloud server,
and the remaining components on the edge server.

\meta{maybe import the image from the pulverisation paper?}

Although the idea behind pulverisation is simple,
finding a way to implement it effectively requires tackling several challenges at different levels:
\begin{itemize}
    \item \textbf{communication}: spliting logical devices into small deployment units implies communication among them,
    thus requiring to consider networking at two levels:
    across pulverised components (intra-device) and among logical devices (inter-device);
    \item \textbf{portability}: hosts will have very diverse hardware specifications, operang systems, and software stacks,
    \item \textbf{runtime}: runtime reconf how to handle the communication between pulverised components across different runtimes?
    \item \textbf{language}: for the idea to be exploitable by designers is quintessential that
    the pulverised configuration
    and the mapping of pulverised components to the underlying infrastructure
    can be expressed nimbly and, possibly, declaratively.
\end{itemize}

\subsection{Domain-specific languages}

In principle, there are several possibilities to implement a pulverisation configurator and runtime:
as a library
configured by a program written in a general-purpose language,
as a framework/runtime configured by means of configuration files,
or as a \ac{dsl} configured with its own custom syntax.
%
These approaches have different trade-offs.
%
A (well designed) library can be flexible as the host language can be used to express peculiar configurations
and easier to adopt to users acquainted with the host language;
but its configuration may quickly become imperative and harder to maintain as complexity grows.
%
A framework/runtime configured via declarative files enforces declarativity at the configuration level,
but its flexibility is limited,
as options that have not been accounted for at design time can hardly be injected through configuration files.
%
Finally, a \ac{dsl} can be designed to be as expressive as needed,
but it has high maintenance cost (as the language maintenance costs stack upon those of the library/API) and, potentially,
a steep learning curve due to the need of learning a new (custom) language.
%
Recent evolution in programming languages,
however,
open to an additional strategy:
the construction of \emph{internal} \acp{dsl},
hybrids between libraries and stand-alone (external) \acp{dsl}.
%
In fact, modern languages such as Kotlin, Groovy, Ruby, and Scala~\cite{Riti2018}
provide specific syntactic features to enable the construction of APIs whose ergonomy is akin to the one of a dedicated language,
but that are valid fragments in the host language.
%
Although internal \acp{dsl} are de facto libraries in the host programming language
(there is no clear boundary defining when a library becomes a \ac{dsl}\footnote{\url{https://archive.is/wip/xAeiX}}),
from a practical perspective
they allow for great flexibility and ergonomy
(although not total as the one of a custom \ac{dsl}, as they are subject to the syntactic constraints of the host language)
while retaining a reduced maintenance cost
(as the host language ecosystem and tooling can be reused directly)
and a gentle learning curve
(as the syntax will be largely familiar to the host language users).
%
The internal DSL approach has been successfully applied in several domains,
spanning from
build systems\footnote{\url{https://archive.is/5xtaN}}
and ontologies~\cite{DBLP:journals/jossw/Balhoff16} to
hardware design~\cite{DBLP:journals/trets/SerreP20} to
logic~\cite{2pkt-swx16} and aggregate programming~\cite{DBLP:journals/softx/CasadeiVAP22}.

\section{A \ac{dsl} for runtime reconfiguration of pulverised systems}\label{sec:contribution}

From the previous section,
we can identify two main phases in the pulverisation process:
\begin{enumerate*}[label=\it{(\roman*)}]
  \item the definition of the available devices and their capabilities (\emph{infrastructure}); and
  \item the allocation of the pulverised components to them (\emph{runtime}).
\end{enumerate*}
%
Coherently withush the single responsibility principle,
we decided to capture these phases into two distinct \acp{dsl}.

\subsection{Infrastructure and requirements}

The infrastructure \ac{dsl} captures the concepts of
\emph{device type}, \emph{component}, \emph{capability}, and \emph{requirement}.
%
A reference sample is presented in \Cref{lst:system-configuration}.
%
The DSL provides simple means to define capabilities as types in the host language,
and then to associate them to pulverised components for each device type.
%
This \ac{dsl} is meant to define constraints that the application imposes on the infrastructure,
ruling out configurations that are not capable to support the system
(for instance, deploying the sensor component of a device in a host that exposes no sensor).
%
All combinations of components and capabilities that are defined as supported become instead amenable to
\emph{runtime reconfiguration}.
%
Notice, for instance, that \texttt{Behavior} in \texttt{iot-sensor} is defined as executable on any of host exposing
\texttt{HighCPU} and/or \texttt{EmbeddedDevice} as capabilities:
it implies that the component can be moved from at runtime across any host implementing any such capability.

\lstinputlisting[
    float=ht,
    language=Kotlin,
    caption={
        Example infrastructure configuration,
        defining three capabilities and a system composed of two device types,
        each component of which is then bound to the set of capabilities it needs to execute.
    },
    label=lst:system-configuration,
]{listings/SystemConfig.kt}

\subsection{Runtime and reconfiguration}

The second \ac{dsl} supports the definition of the mapping between pulverised components and specific hosts,
as well as the definition of reactive reconfiguration policies.
%
The~\Cref{lst:runtime-configuration} provides an example of the usage of the domain-specific language where is defined the runtime configuration of the system.
%
The framework define the concept of \texttt{Host} that is the representation of an available physical host where the components can be deployed;
for each host is possible to specify the capabilities that it implements.
%
In this way, the framework can check if a host can execute a component by verifying if the host implements the required capabilities.
%
The runtime is configured be specifying for each implementation of a \emph{component},
its associated startup host enabling the definition of the initial deployment of the system.
%
The most relevant part of the domain-specific language, is the definition of the reconfiguration rules:
the framework models the concept of \texttt{ReconfigurationEvent}
that is the event that triggers the reconfiguration of the system.
%
The DSL allows the association of a \texttt{ReconfigurationEvent}
to a new deployment of the system which is defined as the new association between component and host.

\lstinputlisting[
    float=ht,
    language=Kotlin,
    caption={
        Example of the usage of the domain-specific language for the runtime configuration.
        The example defines the runtime configuration of the system, specifying the initial deployment and the reconfiguration rules.
    },
    label=lst:runtime-configuration,
]{listings/RuntimeConfig.kt}

A \texttt{ReconfigurationEvent} is characterized by the \emph{events}
that it produces and the \emph{condition} that must be satisfied to trigger the reconfiguration.
%
The \emph{events} are represented as an asyncronous stream of valued produced by the device and the
\emph{condition} is a predicate that is evaluated on the stream of events.
%
At the first match of the condition, the reconfiguration is triggered and the system is reconfigured with the new deployment.
%
The~\Cref{lst:reconfiguration-events} shows an example of the definition of a reconfiguration event.

\lstinputlisting[
    float=ht,
    language=Kotlin,
    caption={Example of the definition of a reconfiguration event.},
    label=lst:reconfiguration-events,
]{listings/ReconfigurationEvents.kt}

\subsection{Implementation details}

Also mention that is multiplatform

\section{Evaluation}\label{sec:evaluation}

In this section,
we exercise the proposed framework with two case studies.
%
In the former,
we show a small-scale demonstrator of a safety system warning people when a room capacity is exceeded
to showcase the integration of the framework with established technologies\footnote{
    \url{https://github.com/nicolasfara/ACSOS-2023-pulverization-crowd-room}
};
in the latter,
we simulate a city-scale distributed application deployed for a urban event
and show how the dynamic reconfiguration may help achieving balance between energy consumption and \ac{qos}\footnote{
    \url{https://github.com/nicolasfara/ACSOS-2023-pulverization-evaluation}
}.
%
Both experiments have been released with a permissive open-source license and have been archived for future reference on Zenodo~\cite{TBD}.

\subsection{Small scale: crowd alert}
\label{sec:small-scale-crowd-alert}

In this section we present a simple scenario where the pulverization framework is used to implement a crowd alert system:
we simulate a laboratory where a safety system warns people when they are too close to each other.
%
Each person is equipped with a wearable device that is able to detect the distance from other devices and send the distances data to the
alert system.
%
The people in the laboratory must observe a safety distance, and the system warns them when the distance is not respected by showing a red light
when they are too close to each other, and a green color when the distance is respected (see~\Cref{fig:crowd-alert}).
%
\begin{figure*}[ht]
    \centering
    \includegraphics[width=.8\textwidth]{figures/crow-laboratory-demo.drawio.pdf}
    \caption{
        Representation of the scenario described in the~\Cref{sec:small-scale-crowd-alert}
        where more the people are far from each other, more the color of the screen is green.
        More the people are close to each other, more the color of the screen is red.
        The blue dot represents the wearable device and the link between the devices represents the distance between them.
        The rectangle represents the monitor in the laboratory which shows the congestion level of the laboratory (via the color described above).
    }
    \label{fig:crowd-alert}
\end{figure*}
%
The system is composed of two kind of devices: \emph{wearable} and \emph{laboratory}.
%
The former represents the wearable devices that is worn by the people, and consists of the following pulverized components:
$\beta$, $\chi$, and $\sigma$.
%
The \emph{behaviour} ($\beta$) component is responsible for converting the raw data from the sensor into the distance
between the device and the others; the \emph{sensors} ($\sigma$) component is responsible for perceiving the other devices and
the \emph{communication} ($\chi$) component is responsible for sending the data to the alert system.
%
The latter represents the alert system and consists of the following pulverized components:
$\beta$, $\kappa$, $\chi$, and $\alpha$.
%
The \emph{behaviour} ($\beta$) component is responsible for evaluating the meand distance between the devices,
the \emph{actuators} ($\alpha$) is responsible for triggering the alarm showing a color in the screen,
and the \emph{communication} ($\chi$) component is responsible for receiving the data from the wearable devices.

The infrastructure defined for this scenario is described as follow:

\begin{itemize}
    \item \emph{Smartphones} are the devices used by the people to detect the distance from the others;
    \item \emph{Local PC} is the device used to show the alarm in the laboratory;
    \item \emph{Server} is the device used run the crowd algorithm and the wearable logic. 
\end{itemize}

The initial deployment of the system starts with the $\beta_{werable}$ executed in the \emph{Server},
the $\sigma_{wearable}$ and $\chi_{werable}$ executed in the \emph{Smartphones},
and all the \emph{Laboratory} components are executed in the \emph{Local PC}.
%
Given the infrastracture defined above, we simulate also a condition where the \emph{Server} is overloaded and, via pulverization,
we want to lighteninig the load of the \emph{Server} by moving the $\beta_{werable}$ in the \emph{Smartphones}.
%
Formally, we can write the reconfiguration event as follow: $\beta^{werable}_{server} \xrightarrow{\mathcal{E}} \beta^{werable}_{smartphone}$
where $\mathcal{E}$ represents the reconfiguration event due to the high load in the \emph{Server}.

At the start of the system, each \emph{Werable} device, with the $\sigma$ component,
start to perceive the other devices in the laboratory using the RSSI signal from the Bluetooth.
%
The $\beta$ component, initially executed in the \emph{Server}, starts to compute the distances from the other devices
based on the received RSSI signal from the $\sigma$ component.
%
Once the distances are computed, the $\chi$ component sends the data to the
\emph{Laboratory} containing the dinstances perceived by the device.
%

Similarity, the \emph{Laboratory} device has all the components executed in the \emph{Local PC},
where the $\chi$ component receives the data from the \emph{Wearable},
the $\beta$ component computes the mean distance between the devices.
%
The $\kappa$ component persist in memory the updated devices grpah based on the distances retreived by the $\chi$ component.
and the $\alpha$ component show in the monitor the color based on the mean distance computed by the $\beta$ component.

As soon as the reconfiguration event is triggered, the $\beta$ component of the \emph{Werable} is moved from the \emph{Server} to the \emph{Smartphone}
lighteninig the server and preserving from one side the functional semantic of the system and from the other side maintain the system operational.
%
The reconfiguration of the system in entirely managed by the framework, which handle all the machinery and communication to move the component from
one host to another.
%
With this simple example we show how the pulverization framework can be used in practice to manage a system with different devices and an heterogeneous
infrastructure.
%
Moreover, we show how the pulverization framework can be used adapt the system to changing requirement without loosing the funcional semantic of the system
by describing the system in a declarative way.

\subsection{Large scale: urban event}

\cite{PianiniJOS2013}

\subsubsection{Free variables}

As follow are reported the free variables used in the evaluation:
\begin{itemize}
    \item let $n$ be the number of devices;
    \item let $t_d$ be the discharge time of the battery of the devices;
    \item let $B_l$ be the low battery threshold;
    \item let $B_h$ be the high battery threshold;
    \item let $EPI_{cloud}$ be the energy per instruction of the cloud;
    \item let $EPI_{ratio}$ be the ratio of the consumption of the cloud and the device;
\end{itemize}

\subsubsection{Metrics}

From the variables above are derived the following metrics:

\begin{itemize}
    \item let $\beta_{device}$ be the number of \emph{behaviour} executed in the device;
    \item let $\beta_{cloud}$ be the number of \emph{behaviour} executed in the cloud;
    \item let $C_{\%}$ be the average battery percentage of the devices;
    \item let $P_{devices}$ be the consumed power of the devices;
    \item let $P_{cloud}$ be the consumed power of the cloud;
    \item let $P_{total}$ be the total consumed power of the system;
    \item let $I_{cloud}$ be the number of server instances of the cloud;
    \item let $\$_{cloud}$ be the cost of the cloud;
\end{itemize}

\subsubsection{Results}



\section{Related Work}
\label{sec:rw}

This work provides 
 \acp{dsl}
 for specifying 
 distributed systems (partitioned according to the 
 pulverisation model)
 and
 corresponding deployment plans,
 and a framework for executing
 deployment plans and reconfigurations.
%
A way to structure all this 
 is by using the analytical framework of~\cite{DBLP:journals/jss/ArcangeliBL15},
  where the problem of (automatic) deployment of distributed software system is studied by considering
 (i) the nature of software to be deployed,
 (ii) the nature of the deployment domain (i.e. the available infrastructure),
 (iii) how the deployment is designed,
 and 
 (iv) how the deployment is performed.
%
Accordingly, 
 we cover related works about
 languages for 
 specifying distributed systems (\Cref{sec:rw:whatsw}),
 languages for specifying infrastructures and deployments (\Cref{sec:rw:depdesc}),
 and
 techniques for automatic deployment and reconfiguration (\Cref{sec:rw:autodep}).
 
 
 
\subsection{Application description languages: component-based software engineering and the pulverisation model}
\label{sec:rw:whatsw}
%
%% A first distinction revolves around whether 
%% the distributed software to be deployed 
%% is a monolith 
%% or is already broken into different components.
%
We consider a distributed application 
 as a graph of deployable units.
%
This partitioning may be 
 manually specified at development time
 (e.g., by explicitly defining and packaging different components)
 or automatically defined
 through \emph{application partitioning} approaches~\cite{DBLP:journals/jnca/LiuASGBQ15}. %exploiting the natural modularity of code (depending on the paradigm and language adopted).
 
In our approach, the application partitioning into components is manually specified through a \ac{dsl}.
%
Therefore, it can be framed in the context of \emph{component-based software engineering},
 with ~\cite{vale2016component-based-se} providing a comprehensive review.
%
The specification or design of distributed systems
 may leverage
 component models~\cite{DBLP:journals/tse/CrnkovicSVC11},
 architectural description languages~\cite{DBLP:journals/tse/MedvidovicT00},
 service-based compositions~\cite{DBLP:journals/csur/LemosDB16}, 
 or frameworks.
%

Specifically,
 this work builds on the \emph{pulverisation} component model~\cite{FI2020-pulverization,IEEE-IoTJ-pulverization-simulation},
 whereby a large-scale cyber-physical system
 is partitioned into a graph of devices
 where each device is split into five deployable components:
 (i) sensors interface, 
 (ii) actuators interface, 
 (iii) behaviour, 
 (iv) state, and 
 (v) communication component.
%
In~\cite{IEEE-IoTJ-pulverization-simulation},
 a methodology on top of the pulverisation model
 is proposed
 for generating and testing deployments through simulation.

Additionally,
 the approach of specifying in a single codebase 
 parts of the structure, behaviour, and/or interaction 
 for a whole distributed system
 is also related to \emph{macroprogramming}~\cite{Casadei2023macro}
 and, in particular, to \emph{multi-tier programming} paradigm~\cite{DBLP:journals/csur/WeisenburgerWS20},
 where the deployment units for different tiers (e.g., client and server tiers; or view, business logic, and data tiers) are obrained by compilation or interpretation of a single codebase.



\subsection{Infrastructure and deployment description languages}
\label{sec:rw:depdesc}

A \emph{deployment plan} is a configured mapping of a software system onto a deployment domain.
%
Given a deployable software system developed using the techniques of the previous subsection,
 what is needed now is a language to describe a deployment domain 
 and the deployment mapping.
%
Languages have been proposed 
 targetting specific kinds of deployment domains
 such as the smart grid (cf. the deployment specification language \emph{dspec} in the \emph{Resilient Information Architecture Platform for Smart Grids [RIAPS]} platform~\cite{DBLP:conf/coins/GhoshTKKL22})
 or the cloud (cf. the \emph{Cloud Application Modelling and Execution Language [CAMEL]} multi-\ac{dsl}~\cite{DBLP:journals/jcloudc/AchilleosKRKDOS19}).

In this work,
 we are especially interested deployments over large-scale cyber-physical systems and the edge-fog-cloud continuum.
%
The \emph{MultiScale Autonomic Deployment Language (MuScADeL)}~\cite{DBLP:conf/compsac/BoujbelRLTAL14/muscadel}
 is a \ac{dsl} that allows to express deployment properties of 
 componentised applications on multi-scale deployment domains, i.e., large and heterogeneous infrastructures considered under several viewpoints (device, geography, network, administrative domains, etc.).
%
In~\cite{DBLP:journals/sosym/SongDFSF22},
  a model-based deployment approach is proposed
  targetting so-called \emph{fleets}, i.e.,
  distributed and heterogeneous devices at the edge chaaracterised by different cyber-physical contexts (cf. resources, connectivity, etc.).
%
It is based on the \emph{Generation and Deployment
of Smart IoT Systems (GeneSIS)} modelling language, where a \texttt{DeploymentModel} consists of sets of \texttt{Resources} (e.g., \texttt{Component}s, specialised by \texttt{InfrastructureComponent}s and \texttt{SoftwareComponent}s) with associated \texttt{Property}s and \texttt{Link}s.

\subsection{Automatic/autonomic deployment and reconfiguration}
\label{sec:rw:autodep}
%
A comprehensive conceptual framework
 on automatic deployment of distributed systems
 is provided in a 2015 survey by Arcangeli et al. \cite{DBLP:journals/jss/ArcangeliBL15}.
%
A more recent survey by Coullon et al. focusses
 on formal techniques for verifying the correctness of reconfigurations
 in component-based distributed software systems~\cite{coullon2023swreconfig}.
%
Two formal models for specifying reconfigurable architectures are \emph{DR-BIP (Dynamically Reconfigurable - Behaviour Interaction Priority model)}~\cite{Ballouli18dr-bip}
and \emph{DReAM (Dynamically Reconfigurable Architectural Modelling)}~\cite{denicola2020dream-dynamic-reconfig-arch-modelling}.
%
Both are based on the same conceptual model: they 
 feature \emph{components} (capturing behaviour), \emph{connectors} (capturing interaction between components' \emph{ports}), 
\emph{maps} (logical topologies),
and \emph{deployments} (associating components to map locations),
overall organised in \emph{motifs} (dynamic architectural configurations),
to model and analyse dynamic architectures.
%
\meta{TODO: say something about our positioning wrt verification of reconfigurations}

In the \emph{osmotic computing} approach~\cite{DBLP:journals/computer/VillariFDRJR19},
 microservices (the solvent)
 can migrate across 
 the edge-cloud infrastructure (the solution),
 passing through layer boundaries (the semi-permeable membranes),
 in order to keep a balance in the desired properties (the solute).
%
The \emph{ASSL (Autonomic System Specification Language)}~\cite{DBLP:conf/birthday/VassevH97}
 supports the specification
 of autonomic elements,
 interaction protocols,
 and \emph{self-management policies} based on fluents (states), events, and actions.
%
%In \emph{ConfSolve}~\cite{DBLP:conf/saso/HewsonAG13},
% the language supports the specification of logical \emph{reconfiguration constraints}, which are then solved as a constraint satisfaction problem.
%
The \emph{AWaRE DSL (ADSL)}~\cite{DBLP:conf/aswec/ChhetriLUVKNR18/adsl} supports constraint-based self-management, leveraging managing agents. The language enables the specification of the domain model (in terms of components), the problem structure model (in terms of constraints), the agent architecture model (in terms of agents, roles, and their coordination), and the assignment model (in terms of management problem assignment strategies).
%
Similar, earlier approaches based on the specification of \emph{constraint-sets} include \emph{DELADAS}~\cite{Dearle2004deladas}
and \emph{ConfSolve}~\cite{DBLP:conf/saso/HewsonAG13}.
%
\emph{Ctrl-F}~\cite{DBLP:journals/jss/AlvaresRS17}
 is an architectural description language
 with constructs for specifying adaptive behaviour 
 and policies (constraints) for the reconfiguration of system components.
%
These approaches, however, typically suffer from scalability issues.

%%high-level constructs to describe adaptation in software components by means of behavioural programs, i.e., in terms of order and/or conditions under which reconfigurations take place; and policies, i.e., constraints that have to be enforced all along the execution. In other words, Ctrl-Fis a first-class language that is applicable to any Component-based application requiring self-adaptation with formal guarantees.
 
 

%\meta{
%MuScADeL (Multi-Scale Autonomic Deployment Language)~\cite{DBLP:conf/compsac/BoujbelRLTAL14/muscadel}
%
%ADSL (AWaRE DSL)~\cite{DBLP:conf/aswec/ChhetriLUVKNR18/adsl} % and see corresp RW: the most related DSLs are those in the area of automated deployment [17]. Such DSLs include Deladas [31], [32], ConfSolve [15], [33], j-ASD’s DSL [34] and MuScADeL [35], [36].DBLP:journals/jss/AlvaresRS17
%% [17]: J.-P. Arcangeli, R. Boujbel, and S. Leriche, "Automatic deployment of distributed software systems: Definitions and state of the art," Journal of Systems and Software, vol. 103, pp. 198–218, 2015
%%
%%%
%%%\subsection{Approaches to Deployment Independence}
%%%\label{s:rw:deployment-independence}
%%%
%%%\meta{TODO: add works on deployment independence, e.g., osmotic~\citep{DBLP:journals/computer/VillariFDRJR19}, BIP~\citep{lekidis2015bip-wsn,bastarrica2001optimization-techniques-deployment-components-bip}}
%%%
%%%We highlight a number of representatieve research efforts on deployment and automatic reconfiguration of systems.
%%%%
%%%%For instance, 
%%%\emph{Osmotic computing}~\cite{DBLP:journals/computer/VillariFDRJR19} is an approach to opportunistic deployment of microservices on the edge-fog-cloud platform.
%%%An osmotic platform aims to reach and maintain an ``osmotic equilibrium'' 
%%%between infrastructural and application requirements
%%%by automatically migrating microservices to deployment locations.
%%%
%%However, the approach mainly targets centrally orchestrated systems.
%%%
%%Other approaches leverage component-based, architectural descriptions to decouple application logic and deployment.
%%%
%%For instance, \emph{DR-BIP (Dynamically Reconfigurable - Behaviour Interaction Priority model)}~\cite{,Ballouli18dr-bip}
%%and \emph{DReAM (Dynamically Reconfigurable Architectural Modelling)}~\cite{denicola2020dream-dynamic-reconfig-arch-modelling}
%%use \emph{components} (capturing behaviour), \emph{connectors} (capturing interaction between components' \emph{ports}), 
%%\emph{maps} (logical topologies),
%%and \emph{deployments} (associating components to map locations),
%%overall organised in \emph{motifs} (dynamic architectural configurations),
%%to model and analyse dynamic architectures.
%%%
%%
%%These approaches have some similarity with the approach presented in this paper, but they are arguably more complex and our  
%%%than the one introduced in this paper,
%% %, though also fostering an exogenous, declarative (logics-based) modelling approach.
%%approach explicitly addresses self-organising CPS.
%%%
%%%
%%%By constrast, our approach explicitly addresses self-organising CPS.
%%%
%%%A more in-depth, formal comparison is left as future work.
%}

\section{Conclusion and future work}\label{sec:conclusion}

global policies

\bibliographystyle{IEEEtran}
\bibliography{bibliography}

%\vspace{12pt}
%\color{red}
%IEEE conference templates contain guidance text for composing and formatting conference papers. Please ensure that all template text is removed from your conference paper prior to submission to the conference. Failure to remove the template text from your paper may result in your paper not being published.

\end{document}
